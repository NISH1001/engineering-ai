<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Search Techniques</title>

		<meta name="description" content="Experience">
		<meta name="author" content="Paradox">

		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="./css/reveal.css">
		<link rel="stylesheet" href="./css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="./lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? './css/print/pdf.css' : './css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

                <section>
                    <div style="font-size: 2.8em"><br><font color="#90caf9"><span style="font-size:1.3em">Search Techniques</span></font></div>
                    <div>
                        <span style="font-size: 0.6em;"><font color="#fff">Nishan Pantha / <i>@nishparadox</i></font></span> <br>
                        <span style="font-size: 0.6em;"><font color="#fff"><i>nishanpantha@gmail.com</i></font></span> <br>
                    </div>
                </section>

                <section>
                    <section>
                        <h2>What This Chapter Is About</h2>
                    </section>
                    <section>
                        <p><font color="#ff0000">Uninformed </font>Search Techniques</p>
                        <ul>
                            <li>Depth First Search</li>
                            <li>Breadth First Search</li>
                            <li>Depth First Search</li>
                        </ul>
                        <p><font color="#ff0000">Informed </font>Search Techniques</p>
                        <ul>
                            <li>Hill Climbing</li>
                            <li>Best First Search</li>
                            <li>Greedy Search</li>
                            <li>A* Search</li>
                            <li>MiniMax Search</li>
                            <li>Alpha Beta Procedure</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Problem Solving Using Search</h3>
                    </section>
                    <section>
                        <h3>What is Problem Solving?</h3>
                        <p class="fragment fade-in">Generating solutions from observed data</p>
                    </section>
                    <section>
                        <h3>Problem</h3>
                        <p>- Set of Goals</p>
                        <p>- Set of Objects</p>
                        <p>- Set of Operations</p>
                    </section>
                    <section>
                        <h3>Problem Space</h3>
                        <p>All valid states using operations on objects</p>
                    </section>
                    <section>
                        <h3>Search</h3>
                        <p>- Search for solution in problem space</p>
                        <p>- Example: DFS, BFS,...</p>
                    </section>
                    <section>
                        <h3>8 Puzzle</h3>
                        <img src="./images/chapter-2/8-puzzle.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>N Queen</h3>
                        <img src="./images/chapter-2/nqueens.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Path Finding</h3>
                        <img src="./images/chapter-2/path-find.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-2/toh.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Tower of Hanoi</h3>
                        <p><font color="#90caf9">Actions:</font> PICKUP, PUTDOWN, FORWARD, BACKWARD, LEFT, RIGHT</p>
                        <p><font color="#90caf9">Condition-1:</font> Only top ring can be moved at a time</p>
                        <p><font color="#90caf9">Condition-2:</font> Smaller ring cannot be below the large one</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Graph Search</h3>
                        <p>- Direct Graph</p>
                        <p>- Start from Initial State<p>
                        <p>- Use operations</p>
                        <p>- Check Goal State</p>
                    </section>
                    <section>
                        <img src="./images/chapter-2/vacuum-graph.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Tower of Hanoi State Space Representation</h3>
                        <img src="./images/chapter-2/toh-state-space.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>8-Puzzle State Space Representation</h3>
                        <img src="./images/chapter-2/8-puzzle-state-space.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Example: Water Jug Problem</h3>
                        <img src="./images/chapter-2/water-jug-34.png" width="1000" height="550"></img>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Uninformed Search</h3>
                    </section>
                    <section>
                        <p>- Blind Search</p>
                        <p>- Only Problem Defintion</p>
                        <p>- No idea if one non-goal state is better than other</p>
                    </section>
                    <section>
                        <h3>Blind Search</h3>
                        <p>- Visit all the nodes in a a certain order for pre-defined goal</p>
                        <p>- No cleverness</p>
                        <p>- No guarantee of reaching goal state<p>
                    </section>

                    <section>
                        <p>Less Ineffective than Informed Search</p>
                    </section>
                    <section>
                        <h3>Path Finding Problem</h3>
                        <img src="./images/chapter-3/path-finding.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/nodes.png" width="1200" height="650"></img>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Breadth First Search</h3>
                    </section>
                    <section>
                        <h3>How?</h3>
                        <p class="fragment fade-in">- Proceed level by level down the tree</p>
                        <p class="fragment fade-in">- Start from root node and explore all the children, left to right</p>
                        <p></p>
                    </section>
                    <section>
                        <h3>How?</h3>
                        <p>- If no solution found, expand the first(leftmost) child, then second at same depth,...</p>
                        <p></p>
                    </section>
                    <section>
                        <h3>BFS</h3>
                        <img src="./images/chapter-3/bfs.gif" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>BFS</h3>
                        <img src="./images/chapter-3/bfs-path.gif" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Algorithm</h3>
                        <p>- Place start node at the end of queue</p>
                        <p>- Examine the node at the front of queue, then</p>
                        <ul>
                            <li>if queue is EMPTY, STOP</li>
                            <li>if node is GOAL state, STOP</li>
                            <li>else ADD the children of the node to the end of the queue</li>
                        </ul>
                    </section>

                    <section>
                        <h3>Algorithm</h3>
                        <ol>
                            <li>Place the starting node on the queue</li>
                            <li>If queue is EMPTY return FAILURE and STOP</li>
                            <li>If first element on the queue is GOAL node, STOP</li>
                            <li>Otherwise, remove and expand the first element from the queue and place all the children at the end of the queue</li>
                            <li>Goto step 2</li>
                        </ol>
                    </section>
                    <section>
                        <h3>Data Structure?</h3>
                        <p class="fragment fade-in">Queue</p>
                    </section>

                    <section>
                        <h3>Properties</h3>
                        <p class="fragment fade-in"><font color="#90caf9">Complete? </font>Yes! Always reaches GOAL</p>
                        <p class="fragment fade-in"><font color="#90caf9">Time? </font>O(b^d):: Number of nodes generated</p>
                        <p class="fragment fade-in"><font color="#90caf9">Space? </font>O(b^d):: Keeps every node in the memory</p>
                        <p class="fragment fade-in"><font color="#90caf9">Optimal? </font>Yes! except deeper solutions</p>
                    </section>
                    <section>
                        <p>Branching Factor=b and goal found at depth=d</p>
                        <img src="./images/chapter-3/bfs-prop.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Disadvantages?</h3>
                        <p>Space is more problem than time.</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Depth First Search</h3>
                    </section>
                    <section>
                        <h3>How?</h3>
                        <p class="fragment fade-in">- Proceed down a single branch at a time</p>
                        <p class="fragment fade-in">- Expand root node, then leftmost child of the root, then leftmost child of that node,..</p>
                    </section>
                    <section>
                        <h3>DFS</h3>
                        <img src="./images/chapter-3/dfs.gif" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>DFS</h3>
                        <img src="./images/chapter-3/dfs-path.gif" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Data Structure?</h3>
                        <p class="fragment fade-in">Stack (LIFO)</p>
                    </section>
                    <section>
                        <h3>Algorithm</h3>
                        <ol>
                            <li>Place the starting node on the stack</li>
                            <li>If staack is EMPTY return FAILURE and STOP</li>
                            <li>If top element on the stack (pop operation) is GOAL node, STOP</li>
                            <li>Otherwise, remove and expand the top element from the stack and push the children to stack</li>
                            <li>Goto step 2</li>
                        </ol>
                    </section>

                    <section>
                        <h3>Properties</h3>
                        <p class="fragment fade-in"><font color="#90caf9">Complete? </font>No! Fails in infinite depth :: A-B-C-A</p>
                        <p class="fragment fade-in"><font color="#90caf9">Time? </font>O(b^m):: Maximum depth</p>
                        <p class="fragment fade-in"><font color="#90caf9">Space? </font>O(b*m):: Linear Space</p>
                        <p class="fragment fade-in"><font color="#90caf9">Optimal? </font>NO! except deeper solutions</p>
                    </section>
                    <section>
                        <h3>Disadvantages?</h3>
                        <p>Can go to wrong branch and may take very long time to find solution</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Depth-Limited Search</h3>
                        <p>- Optimized DFS</p>
                    </section>
                    <section>
                        <img src="./images/chapter-3/depth-limit.gif" width="1200" height="650"></img>
                    </section>
                    <section>
                        <h3>How?</h3>
                        <p>- Perform DFS but only at a specified depth L</p>
                        <p>- The path length is at max L</p>
                    </section>
                    <section>
                        <h3>Properties</h3>
                        <p class="fragment fade-in"><font color="#90caf9">Complete? </font>No! Solution may be beyond depth level</p>
                        <p class="fragment fade-in"><font color="#90caf9">Time? </font>O(b^L):: Maximum depth</p>
                        <p class="fragment fade-in"><font color="#90caf9">Space? </font>O(b*L):: Linear Space</p>
                        <p class="fragment fade-in"><font color="#90caf9">Optimal? </font>NO!</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Informed Search</h3>
                    </section>
                    <section>
                        <p>- Domain Specific Information</p>
                        <p>- Heuristic Function h(n) : Goodness of a node n</p>
                    </section>
                    <section>
                        <h3>Heuristic Function</h3>
                        <p>h(n) = estimated cost of minimal cost path from n to goal state</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Best First Search</h3>
                    </section>
                    <section>
                        <p>- Uses evaluation function f(n) to select a node for expansion</p>
                        <p>- Node with lowest evaluation function is expanded first</p>
                        <p>Use an <font color="#ff0000">evaluation function</font> for each node -> desirability</p>
                    </section>
                    <section>
                        <ol>
                            <li>Start with initial node and put into priority queue</li>
                            <li>Pick the best node from the queue</li>
                            <li>Generate its successor</li>
                            <li>For each successor do:
                                <br/>
                                - if it haas not been generated before then evaluate it and add to queue
                                <br/>
                                - if it has been generated before, then change the parent and if this new path is better, update the cost 
                                of getting to its any successor node
                                <br/>
                                - if the goal step is found or no more node in the queue then STOP
                            </li>
                            <li>Go to step 2</li>
                        </ol>
                    </section>
                    <section>
                        <h3>Types of Best First Search</h3>
                        <p>- Greedy Best First Search</p>
                        <p>- A* Search</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Greedy Best First</h3>
                        <p>- tries to get as close as it can to the goal<p>
                        <p>- expands the node that appears closest to the goal<p>
                        <p>- Uses only heuristic function</p>
                    </section>
                    <section>
                        <img src="./images/chapter-3/greedy.gif" width="1000" height="550"></img>
                    </section>
                    <section>
                        <p>Evaluation function h(n) = estimate of cost from n to closest goal</p>
                        <p>Example: hsld(n) = straight-line distance from n to goal
                    </section>
                    <section>
                        <p>f(n) = h(n)</p>
                        <p>h(n) = 0 for goal state</p>
                    </section>
                    <section>
                        <h3>Properties</h3>
                        <p class="fragment fade-in"><font color="#90caf9">Complete? </font>NO! Can get stuck in loops</p>
                        <p class="fragment fade-in"><font color="#90caf9">Time? </font>O(b^m):: depends on good heuristic</p>
                        <p class="fragment fade-in"><font color="#90caf9">Space? </font>O(b^m):: Keeps all nodes in memory</p>
                        <p class="fragment fade-in"><font color="#90caf9">Optimal? </font>NO!</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>A*</h3>
                    </section>

                    <section>
                        <p>evaluation function f(n) = g(n) + h(n)</p>
                        <p>g(n) = cost so far to reach n</p>
                        <p>estimated cost from n to goal</p>
                    </section>

                    <section>
                        <img src="./images/chapter-3/astar.gif" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Properties</h3>
                        <p class="fragment fade-in"><font color="#90caf9">Complete? </font>YES!</p>
                        <p class="fragment fade-in"><font color="#90caf9">Time? </font>Exponential</p>
                        <p class="fragment fade-in"><font color="#90caf9">Space? </font>Keeps all nodes in memory</p>
                        <p class="fragment fade-in"><font color="#90caf9">Optimal? </font>YES!</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Hill Climbing</h3>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Adverserial Search</h3>
                    </section>
                    <section>
                        <p>Competitive Environments in which the agents goals are in conflict</p>
                        <p>- Often known as games</p>
                    </section>
                    <section>
                        <h3>Game</h3>
                        <p>- Initial State</p>
                        <p>- A successor function</p>
                        <p>- A terminal test </p>
                        <p>- A Utility function</p>
                    </section>
                    <section>
                        <img src="./images/chapter-3/games.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Adverserial</h3>
                        <p>Opposition between agent's Utility functions</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>MiniMax</h3>
                    </section>
                    <section>
                        <p>- depth first search with limited depth</p>
                        <p>- Static evaluation function for all leaf nodes</p>
                        <p>- assume opponent will make the best move possible</p>
                    </section>
                    <section>
                        <h3>Algorithm</h3>
                        <img src="./images/chapter-3/minimax.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <h3>Algorithm</h3>
                        <img src="./images/chapter-3/mini-max-algo.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/tic-tac-toe.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/minimax-ttt.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/minimax-ttt2.png" width="1000" height="550"></img>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Alpha-Beta Pruning</h3>
                        <p>- Optimized MiniMax</p>
                    </section>
                    <section>
                        <p>- Instead of expanding nodes, we try to infer based on node values</p>
                        <p>- Depends on the order on how nodes are expanded</p>
                    </section>

                    <section>
                        <p>Alpha -> value of best choice so far for MAX (highest value)</p>
                        <p>Beta -> value of best choice so far for MIN (lowest value)</p>
                        <p>Each node keeps track of [alpha, beta]</p>
                    </section>
                    <section>
                        <h3>Initial value</h3>
                        <p>Alpha -> -INF</p>
                        <p>Beta -> +INF</p>
                    </section>
                    <section>
                        <h3>Simple Pruning</h3>
                        <img src="./images/chapter-3/pruning.png" width="1000" height="550"></img>
                    </section>

                    <section>
                        <img src="./images/chapter-3/pruning-2.png" width="1000" height="550"></img>
                    </section>

                    <section>
                        <img src="./images/chapter-3/pruning-3.png" width="1000" height="550"></img>
                    </section>

                    <section>
                        <img src="./images/chapter-3/alpha-beta/1.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/2.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/3.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/4.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/5.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/6.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/7.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/8.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/9.png" width="1000" height="550"></img>
                    </section>
                    <section>
                        <img src="./images/chapter-3/alpha-beta/10.png" width="1000" height="550"></img>
                    </section>
                </section>

                <section data-transition="slide" data-background="#b5533c" data-background-transition="zoom">
                    <p>Research</p>
                </section>

            </div>

		</div>

		<script src="./lib/js/head.min.js"></script>
		<script src="./js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				mouseWheel: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: './plugin/zoom-js/zoom.js', async: true },
					{ src: './plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
